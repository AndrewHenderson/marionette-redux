{"version":3,"sources":["src/mapStateToProps.js","src/mapDispatchToProps.js","src/mergeProps.js","src/isDisplayComponent.js","src/connect.js","src/mixin.js","src/marionette-redux.js"],"names":["mapStateToProps","mapDispatchToProps","dispatch","mergeProps","stateProps","dispatchProps","parentProps","extend","isDisplayComponent","Component","isFunction","prototype","View","Behavior","isObject","connect","_mapStateToProps","_mapDispatchToProps","_mergeProps","_options","options","defaultMapStateToProps","defaultMapDispatchToProps","defaultMergeProps","store","componentInitialize","initialize","componentOnRender","onRender","componentOnDestroy","onDestroy","connectMixin","defaults","_initOptions","initOptions","call","this","props","apply","arguments","mixin","omit","mapState","mapDispatch","window","storeState","getState","state","getInitialState","bindStateEvents","clearCache","componentWillUpdate","on","trySubscribe","key","val","unset","silent","changes","changing","_changing","_previousState","clone","changed","current","prev","_val","_key","isEqual","push","length","_pending","i","trigger","_isRendered","view","attr","bind","bindEvents","bindEntityEvents","stateEvents","unbind","unbindEvents","unbindEntityEvents","finalMapStateToProps","configureFinalMapState","doStatePropsDependOnOwnProps","mappedState","isFactory","computeStateProps","nextStateProps","finalMapDispatchToProps","configureFinalMapDispatch","doDispatchPropsDependOnOwnProps","mappedDispatch","computeDispatchProps","nextDispatchProps","unsubscribe","isSubscribed","subscribe","handleChange","handleDispatchProps","tryUnsubscribe","unbindStateEvents","haveInitialStatePropsBeenDetermined","haveInitialDispatchPropsBeenDetermined","updateDispatchPropsIfNeeded","prevStoreState","haveStatePropsChanged","updateStatePropsIfNeeded","mergedProps","componentWillReceiveProps","setState","MarionetteRedux"],"mappings":"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","file":"marionette-redux.min.js","sourcesContent":["export default function mapStateToProps() {\n  return {}\n}\n","export default function mapDispatchToProps(dispatch) {\n  return {\n    dispatch: dispatch\n  }\n}\n","import { extend } from 'underscore';\nexport default function mergeProps(stateProps, dispatchProps, parentProps) {\n  return extend({}, parentProps, stateProps, dispatchProps)\n}\n","import { isObject, isFunction } from 'underscore'\nimport { View, Behavior } from 'marionette'\n\nexport default function isDisplayComponent(Component) {\n  if (isFunction(Component)) {\n    return Component.prototype instanceof View || Component.prototype instanceof Behavior\n  }\n  if (isObject(Component)) {\n    return Component instanceof View || Component instanceof Behavior\n  }\n  return false\n}\n","import { defaults, omit } from 'underscore';\nimport defaultMapStateToProps from './mapStateToProps'\nimport defaultMapDispatchToProps from './mapDispatchToProps'\nimport defaultMergeProps from './mergeProps'\nimport mixin from './mixin'\nimport isDisplayComponent from './isDisplayComponent';\n\nexport default function connect(_mapStateToProps, _mapDispatchToProps, _mergeProps, _options) {\n\n  const options = _options || {};\n\n  return function(Component) {\n\n    const mapStateToProps = _mapStateToProps || Component.prototype.mapStateToProps || defaultMapStateToProps;\n    const mapDispatchToProps = _mapDispatchToProps || Component.prototype.mapDispatchToProps || defaultMapDispatchToProps;\n    const mergeProps = _mergeProps || Component.prototype.mergeProps || defaultMergeProps;\n    const store = options.store || Component.prototype.store;\n    const componentInitialize = Component.prototype.initialize;\n    const componentOnRender = Component.prototype.onRender;\n    const componentOnDestroy = Component.prototype.onDestroy;\n\n    let connectMixin = defaults({}, {\n\n      initialize(_initOptions) {\n\n        const initOptions = _initOptions || {};\n\n        mixin.initialize.call(this, {\n          mapStateToProps,\n          mapDispatchToProps,\n          mergeProps,\n          store,\n          props: initOptions.props\n        });\n\n        if (componentInitialize) {\n          componentInitialize.apply(this, arguments);\n        }\n      },\n\n      onRender() {\n\n        mixin.onRender.apply(this, arguments);\n\n        if (componentOnRender) {\n          componentOnRender.apply(this, arguments)\n        }\n      },\n\n      onDestroy() {\n\n        mixin.onDestroy.apply(this, arguments);\n\n        if (componentOnDestroy) {\n          componentOnDestroy.apply(this, arguments);\n        }\n      }\n    }, mixin);\n\n    if (!isDisplayComponent(Component)) {\n      connectMixin = omit(connectMixin, 'onRender')\n    }\n\n    return Component.extend(connectMixin)\n  }\n}\n","import {\n  extend,\n  defaults,\n  clone,\n  each,\n  isEqual,\n  isFunction,\n  isObject\n} from 'underscore';\nimport {\n  bindEvents,\n  bindEntityEvents,\n  unbindEvents,\n  unbindEntityEvents\n} from 'marionette';\nimport defaultMapStateToProps from './mapStateToProps';\nimport defaultMapDispatchToProps from './mapDispatchToProps';\nimport defaultMergeProps from './mergeProps';\nimport isDisplayComponent from './isDisplayComponent';\n\nconst mixin = {\n\n  initialize(_options) {\n\n    const options = _options || {};\n\n    this.mapState = options.mapStateToProps || this.mapStateToProps || defaultMapStateToProps;\n    this.mapDispatch = options.mapDispatchToProps || this.mapDispatchToProps || defaultMapDispatchToProps;\n    this.mergeProps = options.mergeProps || this.mergeProps || defaultMergeProps;\n    this.props = this.props || {};\n\n    if (options.props) {\n      extend(this.props, options.props)\n    }\n\n    this.store = options.store || this.store;\n\n    if (!this.store && window && window.store) {\n      this.store = window.store\n    }\n\n    const storeState = this.store.getState();\n    this.state = defaults({\n      storeState: storeState\n    }, this.getInitialState());\n\n    this.bindStateEvents();\n    this.clearCache();\n\n    if (!isDisplayComponent(this)) {\n      this.trySubscribe()\n    } else {\n      if (this.componentWillUpdate) {\n        this.on('render', this.componentWillUpdate)\n      }\n    }\n  },\n\n  getInitialState() {\n    return {}\n  },\n\n  setState(key, val, options) {\n\n    if (key == null) {\n      return this;\n    }\n\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    let state;\n    if (isObject(key)) {\n      state = key;\n      options = val;\n    } else {\n      (state = {})[key] = val;\n    }\n\n    options || (options = {});\n\n    // Extract state and options.\n    const unset      = options.unset;\n    const silent     = options.silent;\n    const changes    = [];\n    const changing   = this._changing;\n    this._changing = true;\n\n    if (!changing) {\n      this._previousState = clone(this.state);\n      this.changed = {};\n    }\n\n    const current = this.state;\n    const changed = this.changed;\n    const prev    = this._previousState;\n\n    // For each `set` state, update or delete the current value.\n    each(state, function(_val, _key) {\n      if (!isEqual(current[_key], _val)) {\n        changes.push(_key);\n      }\n      if (!isEqual(prev[_key], _val)) {\n        changed[_key] = _val;\n      } else {\n        delete changed[_key];\n      }\n      unset ? delete current[_key] : current[_key] = _val;\n    });\n\n    // Trigger all relevant state changes.\n    if (!silent) {\n      if (changes.length) {\n        this._pending = options;\n      }\n      for (let i = 0; i < changes.length; i++) {\n        this.trigger('change:' + changes[i], this, current[changes[i]], options);\n      }\n    }\n\n    // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n    if (changing) {\n      return this;\n    }\n    if (!silent) {\n      while (this._pending) {\n        options = this._pending;\n        this._pending = false;\n        this.trigger('change', this, options);\n        if (isDisplayComponent(this) &&\n          (this._isRendered || (this.view && this.view._isRendered)) &&\n          this.componentWillUpdate\n        ) {\n          this.componentWillUpdate()\n        }\n      }\n    }\n    this._pending = false;\n    this._changing = false;\n    return this\n  },\n\n  getState(attr) {\n    return this.state[attr]\n  },\n\n  bindStateEvents() {\n    const bind = bindEvents || bindEntityEvents;\n    if (this.stateEvents) {\n      bind(this, this, this.stateEvents)\n    }\n  },\n\n  unbindStateEvents() {\n    const unbind = unbindEvents || unbindEntityEvents;\n    if (this.stateEvents) {\n      unbind(this, this, this.stateEvents)\n    }\n  },\n\n  computeStateProps(store, props) {\n    if (!this.finalMapStateToProps) {\n      return this.configureFinalMapState(store, props)\n    }\n\n    const state = store.getState();\n    const stateProps = this.doStatePropsDependOnOwnProps ?\n      this.finalMapStateToProps(state, props) :\n      this.finalMapStateToProps(state);\n\n    return stateProps\n  },\n\n  configureFinalMapState(store, props) {\n    const mappedState = this.mapState(store.getState(), props);\n    const isFactory = isFunction(mappedState);\n\n    this.finalMapStateToProps = isFactory ? mappedState : this.mapState;\n    this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;\n\n    if (isFactory) {\n      return this.computeStateProps(store, props)\n    }\n\n    return mappedState\n  },\n\n  updateStatePropsIfNeeded() {\n    const nextStateProps = this.computeStateProps(this.store, this.props);\n    if (this.stateProps && isEqual(nextStateProps, this.stateProps)) {\n      return false\n    }\n\n    this.stateProps = nextStateProps;\n\n    return true\n  },\n\n  computeDispatchProps(store, props) {\n    if (!this.finalMapDispatchToProps) {\n      return this.configureFinalMapDispatch(store, props)\n    }\n\n    const dispatch = store.dispatch;\n    const dispatchProps = this.doDispatchPropsDependOnOwnProps ?\n      this.finalMapDispatchToProps(dispatch, props) :\n      this.finalMapDispatchToProps(dispatch);\n\n    return dispatchProps\n  },\n\n  configureFinalMapDispatch(store, props) {\n    const mappedDispatch = this.mapDispatch(store.dispatch, props);\n    const isFactory = isFunction(mappedDispatch);\n\n    this.finalMapDispatchToProps = isFactory ? mappedDispatch : this.mapDispatch;\n    this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;\n\n    if (isFactory) {\n      return this.computeDispatchProps(store, props)\n    }\n\n    return mappedDispatch\n  },\n\n  updateDispatchPropsIfNeeded() {\n    const nextDispatchProps = this.computeDispatchProps(this.store, this.props);\n    if (this.dispatchProps && isEqual(nextDispatchProps, this.dispatchProps)) {\n      return false\n    }\n\n    this.dispatchProps = nextDispatchProps;\n\n    return true\n  },\n\n  isSubscribed() {\n    return isFunction(this.unsubscribe)\n  },\n\n  trySubscribe() {\n    if (!this.isSubscribed()) {\n      this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));\n      this.handleDispatchProps();\n      this.handleChange()\n    }\n  },\n\n  tryUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null\n    }\n  },\n\n  onRender() {\n    this.trySubscribe()\n  },\n\n  onDestroy() {\n    this.tryUnsubscribe();\n    this.unbindStateEvents();\n    this.clearCache()\n  },\n\n  clearCache() {\n    this.dispatchProps = null;\n    this.stateProps = null;\n    this.finalMapDispatchToProps = null;\n    this.finalMapStateToProps = null;\n    this.haveInitialStatePropsBeenDetermined = false;\n    this.haveInitialDispatchPropsBeenDetermined = false\n  },\n\n  handleDispatchProps() {\n    if (!this.haveInitialDispatchPropsBeenDetermined) {\n      this.updateDispatchPropsIfNeeded();\n      this.haveInitialDispatchPropsBeenDetermined = true\n    }\n  },\n\n  handleChange() {\n    if (!this.unsubscribe) {\n      return\n    }\n\n    const storeState = this.store.getState();\n    const prevStoreState = this.getState('storeState');\n    if (this.haveInitialStatePropsBeenDetermined && isEqual(prevStoreState, storeState)) {\n      return\n    }\n\n    const haveStatePropsChanged = this.updateStatePropsIfNeeded();\n    this.haveInitialStatePropsBeenDetermined = true;\n\n    if (haveStatePropsChanged) {\n\n      const mergedProps = this.mergeProps(this.stateProps, this.dispatchProps, this.props);\n      this.props = mergedProps;\n\n      isFunction(this.componentWillReceiveProps) && this.componentWillReceiveProps(mergedProps);\n\n      if (isDisplayComponent(this) &&\n        (this._isRendered || (this.view && this.view._isRendered)) &&\n        this.componentWillUpdate\n      ) {\n        this.componentWillUpdate();\n      }\n    }\n\n    this.setState({\n      storeState\n    }, { silent: true })\n  }\n};\n\nexport default mixin;\n","import connect from './connect'\nimport mixin from './mixin'\nimport { version as VERSION } from '../package.json'\n\nconst MarionetteRedux = {\n  connect,\n  mixin,\n  VERSION\n}\n\nexport default MarionetteRedux\n"]}