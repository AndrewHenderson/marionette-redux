{"version":3,"sources":["src/mapStateToProps.js","src/mapDispatchToProps.js","src/mergeProps.js","src/isDisplayComponent.js","src/connect.js","src/mixin.js","src/marionette-redux.js"],"names":["mapStateToProps","mapDispatchToProps","dispatch","mergeProps","stateProps","dispatchProps","parentProps","_","extend","isDisplayComponent","Component","_typeof$1","Marionette","View","Behavior","prototype","connect","_mapStateToProps","_mapDispatchToProps","_mergeProps","_options","options","defaultMapStateToProps","defaultMapDispatchToProps","defaultMergeProps","store","componentInitialize","initialize","componentonRender","onRender","componentOnDestroy","onDestroy","connectMixin","defaults","_initOptions","initOptions","call","this","props","apply","arguments","mixin","omit","mapState","mapDispatch","window","storeState","getState","state","getInitialState","bindStateEvents","clearCache","trySubscribe","key","val","_typeof","unset","silent","changes","changing","_changing","_previousState","clone","changed","current","prev","each","_val","_key","isEqual","push","length","_pending","i","trigger","attr","bind","stateEvents","bindEvents","bindEntityEvents","unbind","unbindEvents","unbindEntityEvents","finalMapStateToProps","configureFinalMapState","doStatePropsDependOnOwnProps","mappedState","isFactory","isFunction","computeStateProps","nextStateProps","finalMapDispatchToProps","configureFinalMapDispatch","doDispatchPropsDependOnOwnProps","mappedDispatch","computeDispatchProps","nextDispatchProps","unsubscribe","isSubscribed","subscribe","handleChange","handleDispatchProps","tryUnsubscribe","unbindStateEvents","haveInitialStatePropsBeenDetermined","haveInitialDispatchPropsBeenDetermined","updateDispatchPropsIfNeeded","prevStoreState","haveStatePropsChanged","updateStatePropsIfNeeded","mergedProps","componentDidReceiveProps","setState","MarionetteRedux"],"mappings":"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","file":"marionette-redux.min.js","sourcesContent":["export default function mapStateToProps() {\n  return {}\n}\n","export default function mapDispatchToProps(dispatch) {\n  return {\n    dispatch: dispatch\n  }\n}\n","import _ from 'underscore';\nexport default function mergeProps(stateProps, dispatchProps, parentProps) {\n  return _.extend({}, parentProps, stateProps, dispatchProps)\n}\n","import Marionette from 'marionette'\n\nexport default function isDisplayComponent(Component) {\n  if (typeof Component === 'object') {\n    return Component instanceof Marionette.View || Component instanceof Marionette.Behavior\n  }\n  if (typeof Component === 'function') {\n    return Component.prototype instanceof Marionette.View || Component.prototype instanceof Marionette.Behavior\n  }\n  return false\n}\n","import _ from 'underscore';\nimport defaultMapStateToProps from './mapStateToProps'\nimport defaultMapDispatchToProps from './mapDispatchToProps'\nimport defaultMergeProps from './mergeProps'\nimport mixin from './mixin'\nimport isDisplayComponent from './isDisplayComponent';\n\nexport default function connect(_mapStateToProps, _mapDispatchToProps, _mergeProps, _options) {\n\n  const options = _options || {};\n\n  return function(Component) {\n\n    const mapStateToProps = _mapStateToProps || Component.prototype.mapStateToProps || defaultMapStateToProps;\n    const mapDispatchToProps = _mapDispatchToProps || Component.prototype.mapDispatchToProps || defaultMapDispatchToProps;\n    const mergeProps = _mergeProps || Component.prototype.mergeProps || defaultMergeProps;\n    const store = options.store || Component.prototype.store;\n    const componentInitialize = Component.prototype.initialize;\n    const componentonRender = Component.prototype.onRender;\n    const componentOnDestroy = Component.prototype.onDestroy;\n\n    let connectMixin = _.defaults({}, {\n\n      initialize(_initOptions) {\n\n        const initOptions = _initOptions || {};\n\n        mixin.initialize.call(this, {\n          mapStateToProps,\n          mapDispatchToProps,\n          mergeProps,\n          store,\n          props: initOptions.props\n        });\n\n        if (componentInitialize) {\n          componentInitialize.apply(this, arguments);\n        }\n      },\n\n      onRender() {\n\n        mixin.onRender.apply(this, arguments);\n\n        if (componentonRender) {\n          componentonRender.apply(this, arguments)\n        }\n      },\n\n      onDestroy() {\n\n        mixin.onDestroy.apply(this, arguments);\n\n        if (componentOnDestroy) {\n          componentOnDestroy.apply(this, arguments);\n        }\n      }\n    }, mixin);\n\n    if (!isDisplayComponent(Component)) {\n      connectMixin = _.omit(connectMixin, 'onRender')\n    }\n\n    return Component.extend(connectMixin)\n  }\n}\n","import _ from 'underscore';\nimport Marionette from 'marionette'\nimport defaultMapStateToProps from './mapStateToProps'\nimport defaultMapDispatchToProps from './mapDispatchToProps'\nimport defaultMergeProps from './mergeProps'\nimport isDisplayComponent from './isDisplayComponent';\n\nconst mixin = {\n\n  initialize(_options) {\n\n    const options = _options || {};\n\n    this.mapState = options.mapStateToProps || this.mapStateToProps || defaultMapStateToProps;\n    this.mapDispatch = options.mapDispatchToProps || this.mapDispatchToProps || defaultMapDispatchToProps;\n    this.mergeProps = options.mergeProps || this.mergeProps || defaultMergeProps;\n    this.props = this.props || {};\n\n    if (options.props) {\n      _.extend(this.props, options.props)\n    }\n\n    this.store = options.store || this.store\n\n    if (!this.store && window && window.store) {\n      this.store = window.store\n    }\n\n    const storeState = this.store.getState();\n    this.state = _.defaults({\n      storeState: storeState\n    }, this.getInitialState());\n\n    this.bindStateEvents();\n    this.clearCache();\n\n    if (!isDisplayComponent(this)) {\n      this.trySubscribe()\n    }\n  },\n\n  getInitialState() {\n    return {}\n  },\n\n  setState(key, val, options) {\n\n    if (key == null) {\n      return this;\n    }\n\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    let state;\n    if (typeof key === 'object') {\n      state = key;\n      options = val;\n    } else {\n      (state = {})[key] = val;\n    }\n\n    options || (options = {});\n\n    // Extract state and options.\n    const unset      = options.unset;\n    const silent     = options.silent;\n    const changes    = [];\n    const changing   = this._changing;\n    this._changing = true;\n\n    if (!changing) {\n      this._previousState = _.clone(this.state);\n      this.changed = {};\n    }\n\n    const current = this.state;\n    const changed = this.changed;\n    const prev    = this._previousState;\n\n    // For each `set` state, update or delete the current value.\n    _.each(state, function(_val, _key) {\n      if (!_.isEqual(current[_key], _val)) {\n        changes.push(_key);\n      }\n      if (!_.isEqual(prev[_key], _val)) {\n        changed[_key] = _val;\n      } else {\n        delete changed[_key];\n      }\n      unset ? delete current[_key] : current[_key] = _val;\n    });\n\n    // Trigger all relevant state changes.\n    if (!silent) {\n      if (changes.length) {\n        this._pending = options;\n      }\n      for (let i = 0; i < changes.length; i++) {\n        this.trigger('change:' + changes[i], this, current[changes[i]], options);\n      }\n    }\n\n    // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n    if (changing) {\n      return this;\n    }\n    if (!silent) {\n      while (this._pending) {\n        options = this._pending;\n        this._pending = false;\n        this.trigger('change', this, options);\n      }\n    }\n    this._pending = false;\n    this._changing = false;\n    return this\n  },\n\n  getState(attr) {\n    return this.state[attr]\n  },\n\n  bindStateEvents() {\n    let bind;\n    if (this.stateEvents) {\n      bind = Marionette.bindEvents || Marionette.bindEntityEvents;\n      bind(this, this, this.stateEvents)\n    }\n  },\n\n  unbindStateEvents() {\n    let unbind;\n    if (this.stateEvents) {\n      unbind = Marionette.unbindEvents || Marionette.unbindEntityEvents;\n      unbind(this, this, this.stateEvents)\n    }\n  },\n\n  computeStateProps(store, props) {\n    if (!this.finalMapStateToProps) {\n      return this.configureFinalMapState(store, props)\n    }\n\n    const state = store.getState();\n    const stateProps = this.doStatePropsDependOnOwnProps ?\n      this.finalMapStateToProps(state, props) :\n      this.finalMapStateToProps(state);\n\n    return stateProps\n  },\n\n  configureFinalMapState(store, props) {\n    const mappedState = this.mapState(store.getState(), props);\n    const isFactory = _.isFunction(mappedState);\n\n    this.finalMapStateToProps = isFactory ? mappedState : this.mapState;\n    this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;\n\n    if (isFactory) {\n      return this.computeStateProps(store, props)\n    }\n\n    return mappedState\n  },\n\n  updateStatePropsIfNeeded() {\n    const nextStateProps = this.computeStateProps(this.store, this.props);\n    if (this.stateProps && _.isEqual(nextStateProps, this.stateProps)) {\n      return false\n    }\n\n    this.stateProps = nextStateProps;\n\n    return true\n  },\n\n  computeDispatchProps(store, props) {\n    if (!this.finalMapDispatchToProps) {\n      return this.configureFinalMapDispatch(store, props)\n    }\n\n    const dispatch = store.dispatch;\n    const dispatchProps = this.doDispatchPropsDependOnOwnProps ?\n      this.finalMapDispatchToProps(dispatch, props) :\n      this.finalMapDispatchToProps(dispatch);\n\n    return dispatchProps\n  },\n\n  configureFinalMapDispatch(store, props) {\n    const mappedDispatch = this.mapDispatch(store.dispatch, props);\n    const isFactory = _.isFunction(mappedDispatch);\n\n    this.finalMapDispatchToProps = isFactory ? mappedDispatch : this.mapDispatch;\n    this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;\n\n    if (isFactory) {\n      return this.computeDispatchProps(store, props)\n    }\n\n    return mappedDispatch\n  },\n\n  updateDispatchPropsIfNeeded() {\n    const nextDispatchProps = this.computeDispatchProps(this.store, this.props);\n    if (this.dispatchProps && _.isEqual(nextDispatchProps, this.dispatchProps)) {\n      return false\n    }\n\n    this.dispatchProps = nextDispatchProps;\n\n    return true\n  },\n\n  isSubscribed() {\n    return _.isFunction(this.unsubscribe)\n  },\n\n  trySubscribe() {\n    if (!this.isSubscribed()) {\n      this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));\n      this.handleDispatchProps();\n      this.handleChange()\n    }\n  },\n\n  tryUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null\n    }\n  },\n\n  onRender() {\n    this.trySubscribe()\n  },\n\n  onDestroy() {\n    this.tryUnsubscribe();\n    this.unbindStateEvents();\n    this.clearCache()\n  },\n\n  clearCache() {\n    this.dispatchProps = null;\n    this.stateProps = null;\n    this.finalMapDispatchToProps = null;\n    this.finalMapStateToProps = null;\n    this.haveInitialStatePropsBeenDetermined = false;\n    this.haveInitialDispatchPropsBeenDetermined = false\n  },\n\n  handleDispatchProps() {\n    if (!this.haveInitialDispatchPropsBeenDetermined) {\n      this.updateDispatchPropsIfNeeded();\n      this.haveInitialDispatchPropsBeenDetermined = true\n    }\n  },\n\n  handleChange() {\n    if (!this.unsubscribe) {\n      return\n    }\n\n    const storeState = this.store.getState();\n    const prevStoreState = this.getState('storeState');\n    if (this.haveInitialStatePropsBeenDetermined && _.isEqual(prevStoreState, storeState)) {\n      return\n    }\n\n    const haveStatePropsChanged = this.updateStatePropsIfNeeded();\n    this.haveInitialStatePropsBeenDetermined = true;\n\n    if (haveStatePropsChanged) {\n\n      const mergedProps = this.mergeProps(this.stateProps, this.dispatchProps, this.props);\n      this.props = mergedProps;\n\n      _.isFunction(this.componentDidReceiveProps) && this.componentDidReceiveProps(mergedProps)\n    }\n\n    this.setState({\n      storeState\n    })\n  }\n};\n\nexport default mixin;\n","import connect from './connect'\nimport mixin from './mixin'\nimport { version as VERSION } from '../package.json'\n\nconst MarionetteRedux = {\n  connect,\n  mixin,\n  VERSION\n}\n\nexport default MarionetteRedux\n"]}