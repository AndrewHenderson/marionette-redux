{"version":3,"names":[],"mappings":"","sources":["marionette-redux.js"],"sourcesContent":["// Marionette Redux\n// ----------------------------------\n// v0.1.7\n//\n// Copyright (c)2016 Andrew Henderson.\n// Distributed under MIT license\n\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone.marionette')) :\n\ttypeof define === 'function' && define.amd ? define(['underscore', 'backbone.marionette'], factory) :\n\t(global.MarionetteRedux = factory(global._,global.Marionette));\n}(this, (function (underscore,backbone_marionette) { 'use strict';\n\nfunction mapStateToProps() {\n  return {};\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    dispatch: dispatch\n  };\n}\n\nfunction mergeProps(stateProps, dispatchProps, parentProps) {\n  return underscore.extend({}, parentProps, stateProps, dispatchProps);\n}\n\nfunction isDisplayComponent(Component) {\n  if (underscore.isFunction(Component)) {\n    return Component.prototype instanceof backbone_marionette.View || Component.prototype instanceof backbone_marionette.Behavior;\n  }\n  if (underscore.isObject(Component)) {\n    return Component instanceof backbone_marionette.View || Component instanceof backbone_marionette.Behavior;\n  }\n  return false;\n}\n\nvar mixin = {\n  initialize: function initialize(_options) {\n\n    var options = _options || {};\n\n    this.mapState = options.mapStateToProps || this.mapStateToProps || mapStateToProps;\n    this.mapDispatch = options.mapDispatchToProps || this.mapDispatchToProps || mapDispatchToProps;\n    this.mergeProps = options.mergeProps || this.mergeProps || mergeProps;\n    this.props = this.props || {};\n\n    if (options.props) {\n      underscore.extend(this.props, options.props);\n    }\n\n    this.store = options.store || this.store;\n\n    if (!this.store && window && window.store) {\n      this.store = window.store;\n    }\n\n    var storeState = this.store.getState();\n    this.state = underscore.defaults({\n      storeState: storeState\n    }, this.getInitialState());\n\n    this.bindStateEvents();\n    this.clearCache();\n\n    if (!isDisplayComponent(this)) {\n      this.trySubscribe();\n    }\n  },\n  getInitialState: function getInitialState() {\n    return {};\n  },\n  setState: function setState(key, val, options) {\n\n    if (key == null) {\n      return this;\n    }\n\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    var state = void 0;\n    if (underscore.isObject(key)) {\n      state = key;\n      options = val;\n    } else {\n      (state = {})[key] = val;\n    }\n\n    options || (options = {});\n\n    // Extract state and options.\n    var unset = options.unset;\n    var silent = options.silent;\n    var changes = [];\n    var changing = this._changing;\n    this._changing = true;\n\n    if (!changing) {\n      this._previousState = underscore.clone(this.state);\n      this.changed = {};\n    }\n\n    var current = this.state;\n    var changed = this.changed;\n    var prev = this._previousState;\n\n    // For each `set` state, update or delete the current value.\n    underscore.each(state, function (_val, _key) {\n      if (!underscore.isEqual(current[_key], _val)) {\n        changes.push(_key);\n      }\n      if (!underscore.isEqual(prev[_key], _val)) {\n        changed[_key] = _val;\n      } else {\n        delete changed[_key];\n      }\n      unset ? delete current[_key] : current[_key] = _val;\n    });\n\n    // Trigger all relevant state changes.\n    if (!silent) {\n      if (changes.length) {\n        this._pending = options;\n      }\n      for (var i = 0; i < changes.length; i++) {\n        this.trigger('change:' + changes[i], this, current[changes[i]], options);\n      }\n    }\n\n    // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n    if (changing) {\n      return this;\n    }\n    if (!silent) {\n      while (this._pending) {\n        options = this._pending;\n        this._pending = false;\n        this.trigger('change', this, options);\n      }\n    }\n    this._pending = false;\n    this._changing = false;\n    return this;\n  },\n  getState: function getState(attr) {\n    return this.state[attr];\n  },\n  bindStateEvents: function bindStateEvents() {\n    var bind = backbone_marionette.bindEvents || backbone_marionette.bindEntityEvents;\n    if (this.stateEvents) {\n      bind(this, this, this.stateEvents);\n    }\n  },\n  unbindStateEvents: function unbindStateEvents() {\n    var unbind = backbone_marionette.unbindEvents || backbone_marionette.unbindEntityEvents;\n    if (this.stateEvents) {\n      unbind(this, this, this.stateEvents);\n    }\n  },\n  computeStateProps: function computeStateProps(store, props) {\n    if (!this.finalMapStateToProps) {\n      return this.configureFinalMapState(store, props);\n    }\n\n    var state = store.getState();\n    var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);\n\n    return stateProps;\n  },\n  configureFinalMapState: function configureFinalMapState(store, props) {\n    var mappedState = this.mapState(store.getState(), props);\n    var isFactory = underscore.isFunction(mappedState);\n\n    this.finalMapStateToProps = isFactory ? mappedState : this.mapState;\n    this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;\n\n    if (isFactory) {\n      return this.computeStateProps(store, props);\n    }\n\n    return mappedState;\n  },\n  updateStatePropsIfNeeded: function updateStatePropsIfNeeded() {\n    var nextStateProps = this.computeStateProps(this.store, this.props);\n    if (this.stateProps && underscore.isEqual(nextStateProps, this.stateProps)) {\n      return false;\n    }\n\n    this.stateProps = nextStateProps;\n\n    return true;\n  },\n  computeDispatchProps: function computeDispatchProps(store, props) {\n    if (!this.finalMapDispatchToProps) {\n      return this.configureFinalMapDispatch(store, props);\n    }\n\n    var dispatch = store.dispatch;\n    var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);\n\n    return dispatchProps;\n  },\n  configureFinalMapDispatch: function configureFinalMapDispatch(store, props) {\n    var mappedDispatch = this.mapDispatch(store.dispatch, props);\n    var isFactory = underscore.isFunction(mappedDispatch);\n\n    this.finalMapDispatchToProps = isFactory ? mappedDispatch : this.mapDispatch;\n    this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;\n\n    if (isFactory) {\n      return this.computeDispatchProps(store, props);\n    }\n\n    return mappedDispatch;\n  },\n  updateDispatchPropsIfNeeded: function updateDispatchPropsIfNeeded() {\n    var nextDispatchProps = this.computeDispatchProps(this.store, this.props);\n    if (this.dispatchProps && underscore.isEqual(nextDispatchProps, this.dispatchProps)) {\n      return false;\n    }\n\n    this.dispatchProps = nextDispatchProps;\n\n    return true;\n  },\n  isSubscribed: function isSubscribed() {\n    return underscore.isFunction(this.unsubscribe);\n  },\n  trySubscribe: function trySubscribe() {\n    if (!this.isSubscribed()) {\n      this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));\n      this.handleDispatchProps();\n      this.handleChange();\n    }\n  },\n  tryUnsubscribe: function tryUnsubscribe() {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = null;\n    }\n  },\n  onRender: function onRender() {\n    this.trySubscribe();\n  },\n  onDestroy: function onDestroy() {\n    this.tryUnsubscribe();\n    this.unbindStateEvents();\n    this.clearCache();\n  },\n  clearCache: function clearCache() {\n    this.dispatchProps = null;\n    this.stateProps = null;\n    this.finalMapDispatchToProps = null;\n    this.finalMapStateToProps = null;\n    this.haveInitialStatePropsBeenDetermined = false;\n    this.haveInitialDispatchPropsBeenDetermined = false;\n  },\n  handleDispatchProps: function handleDispatchProps() {\n    if (!this.haveInitialDispatchPropsBeenDetermined) {\n      this.updateDispatchPropsIfNeeded();\n      this.haveInitialDispatchPropsBeenDetermined = true;\n    }\n  },\n  handleChange: function handleChange() {\n    if (!this.unsubscribe) {\n      return;\n    }\n\n    var storeState = this.store.getState();\n    var prevStoreState = this.getState('storeState');\n    if (this.haveInitialStatePropsBeenDetermined && underscore.isEqual(prevStoreState, storeState)) {\n      return;\n    }\n\n    var haveStatePropsChanged = this.updateStatePropsIfNeeded();\n    this.haveInitialStatePropsBeenDetermined = true;\n\n    if (haveStatePropsChanged) {\n\n      var mergedProps = this.mergeProps(this.stateProps, this.dispatchProps, this.props);\n      this.props = mergedProps;\n\n      underscore.isFunction(this.componentDidReceiveProps) && this.componentDidReceiveProps(mergedProps);\n    }\n\n    this.setState({\n      storeState: storeState\n    });\n  }\n};\n\nfunction connect(_mapStateToProps, _mapDispatchToProps, _mergeProps, _options) {\n\n  var options = _options || {};\n\n  return function (Component) {\n\n    var mapStateToProps$$1 = _mapStateToProps || Component.prototype.mapStateToProps || mapStateToProps;\n    var mapDispatchToProps$$1 = _mapDispatchToProps || Component.prototype.mapDispatchToProps || mapDispatchToProps;\n    var mergeProps$$1 = _mergeProps || Component.prototype.mergeProps || mergeProps;\n    var store = options.store || Component.prototype.store;\n    var componentInitialize = Component.prototype.initialize;\n    var componentonRender = Component.prototype.onRender;\n    var componentOnDestroy = Component.prototype.onDestroy;\n\n    var connectMixin = underscore.defaults({}, {\n      initialize: function initialize(_initOptions) {\n\n        var initOptions = _initOptions || {};\n\n        mixin.initialize.call(this, {\n          mapStateToProps: mapStateToProps$$1,\n          mapDispatchToProps: mapDispatchToProps$$1,\n          mergeProps: mergeProps$$1,\n          store: store,\n          props: initOptions.props\n        });\n\n        if (componentInitialize) {\n          componentInitialize.apply(this, arguments);\n        }\n      },\n      onRender: function onRender() {\n\n        mixin.onRender.apply(this, arguments);\n\n        if (componentonRender) {\n          componentonRender.apply(this, arguments);\n        }\n      },\n      onDestroy: function onDestroy() {\n\n        mixin.onDestroy.apply(this, arguments);\n\n        if (componentOnDestroy) {\n          componentOnDestroy.apply(this, arguments);\n        }\n      }\n    }, mixin);\n\n    if (!isDisplayComponent(Component)) {\n      connectMixin = underscore.omit(connectMixin, 'onRender');\n    }\n\n    return Component.extend(connectMixin);\n  };\n}\n\nvar version = \"0.1.7\";\n\nvar MarionetteRedux = {\n  connect: connect,\n  mixin: mixin,\n  VERSION: version\n};\n\nreturn MarionetteRedux;\n\n})));\n"],"file":"marionette-redux.js"}